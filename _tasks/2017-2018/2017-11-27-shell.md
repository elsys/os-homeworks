---
problem_type: process
cmdline: "shell"
title:  "Задача №2: Команден интерпретатор - части I и II"
---
0. Условие на задачата

   0. Основна функционалност (20 точки)

      Целта на задачата е да се реализира прост команден интерпретатор `{{ page.cmdline }}`.

      При стартиране на програмата, тя започва да чете редове от стандартния вход и да ги интерпретира. За тази цел програмата трябва да раздели командния ред на думи, като за разделител се използва интервал (`’ ’`).

      Например, ако на стандартния вход се напише следния ред:
      ```
      /bin/ls -l /usr/include
      ```
      то командния интерпретатор трябва го превърне в следния масив от думи:
      ```
      {"/bin/ls", "-l", "/usr/include"}
      ```

      Първата дума се интерпретира като име на файл, който трябва да се изпълни. Програмата трябва да се опита да изпълни този файл, а като аргументи от командния ред трябва се предаде масив от всички думи в командния ред.

      В разгледания пример, при команден ред:
      ```
      /bin/ls -l /usr/include
      ```
      програмата трябва да се опита да изпълни файла и да му предаде следния масив от аргументи:
      ```
      {"/bin/ls", "-l", "/usr/include"}
      ```

   0. Създаване на pipe

      Интерпретатора трябва да се развие `{{ page.cmdline }}, като се добави възможност за създаване на pipe между две приложения (команди).

      Програмата трябва да третира по специален начин символът `|`, който се използва за създаване на pipe между приложения.

      Например, ако на интерпретатора се подаде командата:
      ```
      /bin/ls -l /usr/include | /bin/wc
      ```
      то командния интерпретатор трябва:
         * да създаде два процеса;
         * да създаде pipe между двата процеса, така че стандартния изход на първия процес да бъде насочен към стандартния вход на втория процес;
         * в рамките на първия процес да изпълни командата `/bin/ls -l /usr/include`;
         * в рамките на втория процес да изпълни командата `/bin/wc`.

   0. Обработка на грешки (20 точки)

      Ако първата дума от командният ред не е име на файл, то програмата трябва да изведе съобщение `No such file or directory`. Например, ако на стандартния вход на програмата се въведе `./aa` и в текущата директория няма файл с такова име, то програмата трябва да формира следното съобщение:
      ```
      ./aa
      ./aa: No such file or directory
      ```

   0. Допълнителни изисквания

      За обработка на командия ред в рамките на програмата трябва да се дефинира функция `parse_cmdline`, която трябва да има следната сигнатура:
      ```
      char **parse_cmdline( const char *cmdline );
      ```

      Функцията `parse_cmdline()` трябва да приема като аргумент C-string и да връща масив от C-стрингове. Върнатия масив от C-стрингове трябва да бъде оформен така, че да може директно да се подаде като втори аргумент на функция.
      ```
      execv( const char *filename, char *const argv[] );
      ```

      За изпълнение на подадените команди трябва да се използва комбинация от обръщания към функциите
      ```
      pid_t fork( void );
      ```
      и
      ```
      execv( const char *filename, char *const argv[] );
      ```

      След завършване на работата на създадения по този начин процес, родителския процес задължително трябва да провери статуса на завършване на детето като използва някой от вариантите на функциите `wait*`, например функцията
      ```
      pid_t waitpid( pid_t pid, int *status, int options );
      ```

      Командния интерпретатор трябва да позволява организиране на pipe между две (или повече) приложения (команди).

      За пренасочване на стандартния вход/изход трябва да се използва системната функция:
      ```
      int dup2( int old, int new );
      ```

      За създаване на pipe трябва да се използва системната функция:
      ```
      int pipe( int filedesc[2] );
      ```

{% include requirements-cmd.md %}
