---
problem_type: process
cmdline: "shell"
title:  "Задача №2: Команден интерпретатор - част I"
---
0. Условие на задачата

   0. Основна функционалност (20 точки)

      Целта на задачата е да се реализира прост команден интерпретатор `{{ page.cmdline }}`.

      При стартиране на програмата, тя започва да чете редове от стандартния вход и да ги интерпретира. За тази цел програмата трябва да раздели командния ред на думи, като за разделител се използва интервал (`’ ’`).

      Например, ако на стандартния вход се напише следния ред:
      ```
      /bin/ls -l /usr/include
      ```
      то командния интерпретатор трябва го превърне в следния масив от думи:
      ```
      {"/bin/ls", "-l", "/usr/include"}
      ```

      Първата дума се интерпретира като име на файл, който трябва да се изпълни. Програмата трябва да се опита да изпълни този файл, а като аргументи от командния ред трябва се предаде масив от всички думи в командния ред.

      В разгледания пример при команден ред:
      ```
      /bin/ls -l /usr/include
      ```
      програмата трябва да се опита да изпълни файла и да му предаде следния масив от аргументи:
      ```
      {"/bin/ls", "-l", "/usr/include"}
      ```

   0. Обработка на грешки (20 точки)

      Ако първата дума от командният ред не е име на файл, то програмата трябва да изведе съобщение `No such file or directory`. Например, ако на стандартния вход на програмата се въведе `./aa` и в текущата директория няма файл с такова име, то програмата трябва да формира следното съобщение:
      ```
      $ ./aa
      ./aa: No such file or directory
      ```

      Ако `fork` не успее да създаде нов процес, то трябва да се изведе съобщение за грешка:
      ```
      $ /bin/echo
      fork: Cannot allocate memory
      ```

      В случай на грешка при изпълнение на дадена команда, то вашата програма не трябва да приключва. Програмата ви трябва да продължи да приема команди докато има символи в стандартния вход.

   0. Допълнителни изисквания

      Началото на всеки ред, който очаква потребителски вход, трябва да започва
      с: "$ "

      За обработка на командия ред в рамките на програмата трябва да се дефинира функция `parse_cmdline`, която трябва да има следната сигнатура:
      ```
      char **parse_cmdline( const char *cmdline );
      ```

      Функцията `parse_cmdline()` трябва да приема като аргумент C-string и да връща масив от C-стрингове. Върнатия масив от C-стрингове трябва да бъде оформен така, че да може директно да се подаде като втори аргумент на функция.
      ```
      execv( const char *filename, char *const argv[] );
      ```

      За изпълнение на подадените команди трябва да се използва комбинация от обръщания към функциите
      ```
      pid_t fork( void );
      ```
      и
      ```
      execv( const char *filename, char *const argv[] );
      ```

      След завършване на работата на създадения по този начин процес, родителския процес задължително трябва да провери статуса на завършване на детето като използва някой от вариантите на функциите `wait*`, например функцията
      ```
      pid_t waitpid( pid_t pid, int *status, int options );
      ```

{% include requirements-cmd.md %}
